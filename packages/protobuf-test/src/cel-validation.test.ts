// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Tests for buf.validate CEL-based read-only field omission in generated code.
 *
 * IMPORTANT: The real validation happens at TypeScript compile time, not runtime.
 * These tests verify that the generated TypeScript DEFINITIONS are correct by:
 *
 * 1. Checking the generated .d.ts type structure matches expectations
 * 2. Ensuring TypeScript compilation itself validates the field omissions
 *    (TypeScript will error if trying to assign omitted fields)
 * 3. Verifying that code generation produces valid, usable types
 *
 * NOTE: Runtime tests cannot verify TypeScript type omissions - the real test
 * is that this code compiles successfully with TypeScript's type checker.
 */

import { test } from "node:test";
import * as assert from "node:assert";
import { readFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Path to generated TypeScript definitions
const generatedFilePath = join(
  __dirname,
  "gen/ts,cel_validation/extra/cel-validation_types_pb.ts",
);

// Helper to assert field presence/absence in a type definition body
function assertField(
  typeBody: string,
  fieldName: string,
  shouldExist: boolean,
  message?: string,
) {
  // Regex to match field definition: fieldName: or fieldName?:
  // We use \b to ensure we match the whole word
  const fieldRegex = new RegExp(`\\b${fieldName}\\??\\s*:`);
  const exists = fieldRegex.test(typeBody);

  if (shouldExist) {
    assert.ok(exists, message || `Should include ${fieldName} field`);
  } else {
    assert.ok(
      !exists,
      message || `Should NOT include ${fieldName} field (omitted)`,
    );
  }
}

// Helper to extract type definition body
function getTypeBody(content: string, typeName: string): string {
  const regex = new RegExp(
    `export type ${typeName} = Message<[^>]+> & \\{([\\s\\S]+?)\\}`,
  );
  const match = content.match(regex);
  assert.ok(match, `Should find ${typeName} type definition`);
  return match[1];
}

// Helper to extract union type definition body
function getUnionTypeBody(content: string, typeName: string): string {
  const regex = new RegExp(
    `export type ${typeName} =([\\s\\S]+?)(?=export (const|type))`,
  );
  const match = content.match(regex);
  assert.ok(match, `Should find ${typeName} type definition`);
  return match[1];
}

test("Generated code exists and is valid TypeScript", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  assert.ok(content.length > 0, "Generated file should not be empty");
  assert.ok(
    content.includes("@generated by protoc-gen-es"),
    "Should be generated by protoc-gen-es",
  );
});

test("CelValidationSimple type has literal 'name' field", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationSimple");

  assertField(typeBody, "description", true);
  assertField(typeBody, "age", true);

  // name should be literal empty string
  assert.ok(
    typeBody.includes('name: ""'),
    "name should be literal empty string",
  );
});

test("CelValidationMultiple type has literal 'id' and 'code' fields", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationMultiple");

  assertField(typeBody, "title", true);
  assertField(typeBody, "active", true);

  // id should be literal empty string
  assert.ok(typeBody.includes('id: ""'), "id should be literal empty string");

  // code should be literal 0
  assert.ok(typeBody.includes("code: 0"), "code should be literal 0");
});

test("CelValidationNotHas type omits 'optionalField' due to !has()", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationNotHas");

  assertField(typeBody, "otherField", true);
  assertField(
    typeBody,
    "optionalField",
    false,
    "optionalField should be omitted",
  );
});

test("CelValidationNested type uses Omit for nested field constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationNested");

  assertField(typeBody, "parentField", true);
  assertField(typeBody, "nested", true);

  // Should use Omit for nested type
  assert.ok(
    typeBody.includes("Omit<"),
    "Should use Omit<> for nested field type",
  );
  assert.ok(
    typeBody.includes("childName"),
    "Should reference childName in Omit<>",
  );
  assert.ok(
    typeBody.includes("childCount"),
    "Should reference childCount in Omit<>",
  );
});

test("CelValidationSnakeCase converts field names to camelCase and uses literals", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationSnakeCase");

  assertField(typeBody, "firstName", true);
  assertField(typeBody, "lastName", true);

  // userName should be literal empty string
  assert.ok(
    typeBody.includes('userName: ""'),
    "userName should be literal empty string",
  );
});

test("CelValidationNoCel includes ALL fields when no CEL constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationNoCel");

  assertField(typeBody, "name", true);
  assertField(typeBody, "description", true);
});

test("CelValidationOr includes ALL fields (OR doesn't create read-only)", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  // OR constraint generates a union type
  assert.ok(
    content.includes("export type CelValidationOr ="),
    "Should find CelValidationOr type definition",
  );

  const unionBody = getUnionTypeBody(content, "CelValidationOr");

  // Now we expect fields to be present as literal types in the branches
  // Branch 1: field1 is empty -> field1: ""
  // Branch 2: field2 is empty -> field2: ""

  assert.ok(unionBody.includes('field1: ""'), 'Should include field1: ""');
  assert.ok(unionBody.includes('field2: ""'), 'Should include field2: ""');

  // field3 should be present normally
  assert.ok(unionBody.includes("field3"), "Should include field3");
});

test("CelValidationCombined generates literal types from AND constraint", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationCombined");

  assertField(typeBody, "field3", true);

  // field1 and field2 should be literal empty strings
  assert.ok(
    typeBody.includes('field1: ""'),
    "field1 should be literal empty string",
  );
  assert.ok(
    typeBody.includes('field2: ""'),
    "field2 should be literal empty string",
  );
});

test("CelValidationWithRequired keeps required field, sets readonly field to literal", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationWithRequired");

  assertField(typeBody, "requiredField", true);
  assert.ok(
    typeBody.includes('readonlyField: ""'),
    "readonlyField should be literal empty string",
  );
});

test("Valid types also have correct literal types", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationSimpleValid");

  assertField(typeBody, "description", true);
  assert.ok(
    typeBody.includes('name: ""'),
    "Valid type should also have literal name",
  );
});

test("CelValidationUnion generates union type with literal OR constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationUnion")) {
    console.log("CelValidationUnion not found, skipping");
    return;
  }

  const unionBody = getUnionTypeBody(content, "CelValidationUnion");

  // Check for literal types in union
  assert.ok(
    unionBody.includes('email: ""'),
    'Should include email: "" in one branch',
  );
  assert.ok(
    unionBody.includes('phone: ""'),
    'Should include phone: "" in one branch',
  );
  assert.ok(unionBody.includes("name"), "Should include name field");
});

test("CelValidationNestedUnion generates union type with nested OR constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationNestedUnion")) {
    return;
  }

  const unionBody = getUnionTypeBody(content, "CelValidationNestedUnion");

  assert.ok(
    unionBody.includes("Omit<"),
    "Should use Omit<> for nested union branches",
  );
  assert.ok(
    unionBody.includes("street"),
    "Should reference street in union branches",
  );
  assert.ok(
    unionBody.includes("city"),
    "Should reference city in union branches",
  );
});

test("CelValidationMixedUnion generates complex union type with AND+OR literals", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationMixedUnion")) {
    return;
  }

  const unionBody = getUnionTypeBody(content, "CelValidationMixedUnion");

  // Name is literal empty string globally
  assert.ok(
    unionBody.includes('name: ""'),
    'Should include name: "" property definition',
  );

  // Email and phone should be literal empty strings in respective branches
  assert.ok(unionBody.includes('email: ""'), 'Should include email: ""');
  assert.ok(unionBody.includes('phone: ""'), 'Should include phone: ""');
});

test("CelValidationMultipleNested handles multiple nested constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationMultipleNested")) {
    return;
  }

  const typeBody = getTypeBody(content, "CelValidationMultipleNested");

  assertField(typeBody, "parentName", true);
  assertField(typeBody, "child1", true);
  assertField(typeBody, "child2", true);

  // Should use Omit for both child1 and child2
  // We expect something like:
  // child1?: Omit<NestedChild, "childName">;
  // child2?: Omit<NestedChild, "childValue">;

  assert.ok(
    typeBody.includes("childName"),
    "Should reference childName in Omit",
  );
  assert.ok(
    typeBody.includes("childValue"),
    "Should reference childValue in Omit",
  );
});

test("CelValidationWithRepeated handles repeated fields correctly", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationWithRepeated")) {
    return;
  }

  const typeBody = getTypeBody(content, "CelValidationWithRepeated");

  assert.ok(
    typeBody.includes('singleField: ""'),
    "singleField should be literal empty string",
  );
  assertField(typeBody, "listField", true);
  assertField(typeBody, "nestedList", true);
});

test("CelValidationOrValid uses union with literals", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const unionBody = getUnionTypeBody(content, "CelValidationOrValid");

  assert.ok(
    unionBody.includes('field1: ""'),
    'Should include field1: "" in Valid type union',
  );
  assert.ok(
    unionBody.includes('field2: ""'),
    'Should include field2: "" in Valid type union',
  );
});

test("CelValidationLiteralString generates literal string type", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationLiteralString");

  assertField(typeBody, "status", true);
  assertField(typeBody, "name", true);

  // Check that status field has literal type "active"
  assert.ok(
    typeBody.includes('status: "active"') ||
      typeBody.includes("status: 'active'"),
    "status should have literal type 'active'",
  );
});

test("CelValidationLiteralNumber generates literal number type", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationLiteralNumber");

  assertField(typeBody, "version", true);
  assertField(typeBody, "description", true);

  // Check that version field has literal type 1
  assert.ok(
    typeBody.includes("version: 1"),
    "version should have literal type 1",
  );
});

test("CelValidationLiteralBool generates literal boolean type", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationLiteralBool");

  assertField(typeBody, "enabled", true);
  assertField(typeBody, "note", true);

  // Check that enabled field has literal type true
  assert.ok(
    typeBody.includes("enabled: true"),
    "enabled should have literal type true",
  );
});

test("CelValidationLiteralBoolFalse generates literal boolean false type", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationLiteralBoolFalse");

  assertField(typeBody, "disabled", true);
  assertField(typeBody, "reason", true);

  // Check that disabled field has literal type false
  assert.ok(
    typeBody.includes("disabled: false"),
    "disabled should have literal type false",
  );
});

test("CelValidationLiteralsMultiple generates multiple literal types", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationLiteralsMultiple");

  assertField(typeBody, "type", true);
  assertField(typeBody, "level", true);
  assertField(typeBody, "info", true);

  // Check that type and level have literal types
  assert.ok(
    typeBody.includes('type: "user"') || typeBody.includes("type: 'user'"),
    "type should have literal type 'user'",
  );
  assert.ok(typeBody.includes("level: 5"), "level should have literal type 5");
});

test("CelValidationLiteralOr generates union with literal types", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationLiteralOr")) {
    return;
  }

  const unionBody = getUnionTypeBody(content, "CelValidationLiteralOr");

  // Check for literal types in union branches
  assert.ok(
    unionBody.includes('"admin"') || unionBody.includes("'admin'"),
    "Should include literal 'admin' in one branch",
  );
  assert.ok(
    unionBody.includes('"pending"') || unionBody.includes("'pending'"),
    "Should include literal 'pending' in another branch",
  );

  // Name field should be present
  assert.ok(unionBody.includes("name"), "Should include name field");
});

test("CelValidationLiteralEnum generates literal enum value type", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationLiteralEnum");

  assertField(typeBody, "status", true);
  assertField(typeBody, "description", true);

  // Check that status field has literal type 2 (which corresponds to STATUS_ACTIVE)
  // Note: It might generate `status: 2` or `status: Status.STATUS_ACTIVE` depending on implementation.
  // Since we are injecting the literal value directly from the parser which extracts '2', it will likely be `status: 2`.
  assert.ok(
    typeBody.includes("status: 2"),
    "status should have literal type 2",
  );
});
