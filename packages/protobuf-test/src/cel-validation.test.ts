// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Tests for buf.validate CEL-based read-only field omission in generated code.
 *
 * IMPORTANT: The real validation happens at TypeScript compile time, not runtime.
 * These tests verify that the generated TypeScript DEFINITIONS are correct by:
 *
 * 1. Checking the generated .d.ts type structure matches expectations
 * 2. Ensuring TypeScript compilation itself validates the field omissions
 *    (TypeScript will error if trying to assign omitted fields)
 * 3. Verifying that code generation produces valid, usable types
 *
 * NOTE: Runtime tests cannot verify TypeScript type omissions - the real test
 * is that this code compiles successfully with TypeScript's type checker.
 */

import { test } from "node:test";
import * as assert from "node:assert";
import { readFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Path to generated TypeScript definitions
const generatedFilePath = join(
  __dirname,
  "gen/ts,cel_validation/extra/cel-validation_types_pb.ts",
);

test("Generated code exists and is valid TypeScript", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  assert.ok(content.length > 0, "Generated file should not be empty");
  assert.ok(
    content.includes("@generated by protoc-gen-es"),
    "Should be generated by protoc-gen-es",
  );
});

test("CelValidationSimple type omits 'name' field from Shape", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  // Find the CelValidationSimple type definition
  const regex =
    /export type CelValidationSimple = Message<[^>]+> & \{([\s\S]+?)\}/;
  const typeMatch = content.match(regex);
  assert.ok(typeMatch, "Should find CelValidationSimple type definition");

  const typeBody = typeMatch[1];

  // Should include description and age
  assert.ok(
    typeBody.includes("description:"),
    "Should include description field",
  );
  assert.ok(typeBody.includes("age:"), "Should include age field");

  // Should NOT include name field
  assert.ok(
    !typeBody.includes("name:"),
    "Should NOT include name field (omitted due to CEL constraint)",
  );
});

test("CelValidationMultiple type omits 'id' and 'code' fields", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  const regex =
    /export type CelValidationMultiple = Message<[^>]+> & \{([\s\S]+?)\}/;
  const typeMatch = content.match(regex);
  assert.ok(typeMatch, "Should find CelValidationMultiple type definition");

  const typeBody = typeMatch[1];

  // Should include title and active
  assert.ok(typeBody.includes("title:"), "Should include title field");
  assert.ok(typeBody.includes("active:"), "Should include active field");

  // Should NOT include id or code
  assert.ok(!typeBody.includes("id:"), "Should NOT include id field (omitted)");
  assert.ok(
    !typeBody.includes("code:"),
    "Should NOT include code field (omitted)",
  );
});

test("CelValidationNotHas type omits 'optionalField' due to !has()", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  const regex =
    /export type CelValidationNotHas = Message<[^>]+> & \{([\s\S]+?)\}/;
  const typeMatch = content.match(regex);
  assert.ok(typeMatch, "Should find CelValidationNotHas type definition");

  const typeBody = typeMatch[1];

  // Should include otherField
  assert.ok(
    typeBody.includes("otherField:"),
    "Should include otherField field",
  );

  // Should NOT include optionalField
  assert.ok(
    !typeBody.includes("optionalField:"),
    "Should NOT include optionalField (omitted due to !has())",
  );
});

test("CelValidationNested type uses Omit for nested field constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  const regex =
    /export type CelValidationNested = Message<[^>]+> & \{([\s\S]+?)\}/;
  const typeMatch = content.match(regex);
  assert.ok(typeMatch, "Should find CelValidationNested type definition");

  const typeBody = typeMatch[1];

  // Check for nested field (may be optional with '?')
  const hasNested =
    typeBody.includes("nested:") || typeBody.includes("nested?:");
  assert.ok(hasNested, "Should include nested field");
  assert.ok(typeBody.includes("parentField:"), "Should include parentField");

  // Should use Omit for nested type
  assert.ok(
    typeBody.includes("Omit<"),
    "Should use Omit<> for nested field type",
  );
  assert.ok(
    typeBody.includes("childName"),
    "Should reference childName in Omit<>",
  );
  assert.ok(
    typeBody.includes("childCount"),
    "Should reference childCount in Omit<>",
  );
});

test("CelValidationSnakeCase converts field names to camelCase", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  const regex =
    /export type CelValidationSnakeCase = Message<[^>]+> & \{([\s\S]+?)\}/;
  const typeMatch = content.match(regex);
  assert.ok(typeMatch, "Should find CelValidationSnakeCase type definition");

  const typeBody = typeMatch[1];

  // Should have camelCase fields
  assert.ok(
    typeBody.includes("firstName:"),
    "Should include firstName (camelCase)",
  );
  assert.ok(
    typeBody.includes("lastName:"),
    "Should include lastName (camelCase)",
  );

  // Should NOT have userName (was user_name in proto, omitted by CEL)
  assert.ok(
    !typeBody.includes("userName:"),
    "Should NOT include userName (omitted)",
  );
});

test("CelValidationNoCel includes ALL fields when no CEL constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  const regex =
    /export type CelValidationNoCel = Message<[^>]+> & \{([\s\S]+?)\}/;
  const typeMatch = content.match(regex);
  assert.ok(typeMatch, "Should find CelValidationNoCel type definition");

  const typeBody = typeMatch[1];

  // Should include ALL fields - no omissions
  assert.ok(typeBody.includes("name:"), "Should include name field");
  assert.ok(
    typeBody.includes("description:"),
    "Should include description field",
  );
});

test("CelValidationOr includes ALL fields (OR doesn't create read-only)", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  // OR constraint generates a union type, not a single type
  assert.ok(
    content.includes("export type CelValidationOr ="),
    "Should find CelValidationOr type definition",
  );

  // OR constraint (field1 == '' || field2 == '') means "at least one must be empty"
  // NOT "both must be empty", so fields are NOT read-only
  assert.ok(content.includes("field1:"), "Should include field1");
  assert.ok(content.includes("field2:"), "Should include field2");
  assert.ok(content.includes("field3:"), "Should include field3");
});

test("CelValidationCombined omits fields from AND constraint", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  const regex =
    /export type CelValidationCombined = Message<[^>]+> & \{([\s\S]+?)\}/;
  const typeMatch = content.match(regex);
  assert.ok(typeMatch, "Should find CelValidationCombined type definition");

  const typeBody = typeMatch[1];

  // field1 and field2 are in AND constraint, should be omitted
  assert.ok(
    !typeBody.includes("field1:"),
    "Should NOT include field1 (omitted)",
  );
  assert.ok(
    !typeBody.includes("field2:"),
    "Should NOT include field2 (omitted)",
  );
  assert.ok(typeBody.includes("field3:"), "Should include field3");
});

test("CelValidationWithRequired keeps required field, omits readonly field", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  const regex =
    /export type CelValidationWithRequired = Message<[^>]+> & \{([\s\S]+?)\}/;
  const typeMatch = content.match(regex);
  assert.ok(typeMatch, "Should find CelValidationWithRequired type definition");

  const typeBody = typeMatch[1];

  // readonlyField should be omitted
  assert.ok(
    !typeBody.includes("readonlyField:"),
    "Should NOT include readonlyField (omitted)",
  );

  // requiredField should be present
  assert.ok(
    typeBody.includes("requiredField:"),
    "Should include requiredField",
  );
});

test("Valid types also have correct field omissions", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  // Check CelValidationSimpleValid
  const regex =
    /export type CelValidationSimpleValid = Message<[^>]+> & \{([\s\S]+?)\}/;
  const validMatch = content.match(regex);
  assert.ok(validMatch, "Should find CelValidationSimpleValid type definition");

  const validBody = validMatch[1];

  // Should also omit 'name' in Valid type
  assert.ok(
    !validBody.includes("name:"),
    "Valid type should also NOT include name field",
  );
  assert.ok(
    validBody.includes("description:"),
    "Valid type should include description",
  );
});

test("CelValidationUnion generates union type with OR constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  // Skip test if CelValidationUnion is not generated yet
  if (!content.includes("CelValidationUnion")) {
    console.log(
      "CelValidationUnion not found in generated code, skipping test",
    );
    return;
  }

  assert.ok(
    content.includes("export type CelValidationUnion ="),
    "Should find CelValidationUnion type definition",
  );

  // Extract the CelValidationUnion type definition
  const unionRegex =
    /export type CelValidationUnion =([\s\S]+?)(?=export const CelValidationUnionSchema)/;
  const unionMatch = content.match(unionRegex);
  assert.ok(unionMatch, "Should find CelValidationUnion type definition");

  const unionTypeBody = unionMatch[1];

  // OR constraint means fields are not omitted, should be union without Omit
  assert.ok(
    !unionTypeBody.includes("Omit<"),
    "Should NOT use Omit<> for OR constraints in CelValidationUnion",
  );
  assert.ok(
    unionTypeBody.includes("email"),
    "Should reference email in union branches",
  );
  assert.ok(
    unionTypeBody.includes("phone"),
    "Should reference phone in union branches",
  );
  assert.ok(
    unionTypeBody.includes("name"),
    "Should include name field (not omitted)",
  );
});

test("CelValidationNestedUnion generates union type with nested OR constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  // Skip test if CelValidationNestedUnion is not generated yet
  if (!content.includes("CelValidationNestedUnion")) {
    console.log(
      "CelValidationNestedUnion not found in generated code, skipping test",
    );
    return;
  }

  assert.ok(
    content.includes("export type CelValidationNestedUnion ="),
    "Should find CelValidationNestedUnion type definition",
  );

  // Should be a union type
  assert.ok(
    content.includes("Omit<"),
    "Should use Omit<> for nested union branches",
  );
  assert.ok(
    content.includes("street"),
    "Should reference street in union branches",
  );
  assert.ok(
    content.includes("city"),
    "Should reference city in union branches",
  );
});

test("CelValidationMixedUnion generates complex union type with AND+OR", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  // Skip test if CelValidationMixedUnion is not generated yet
  if (!content.includes("CelValidationMixedUnion")) {
    console.log(
      "CelValidationMixedUnion not found in generated code, skipping test",
    );
    return;
  }

  assert.ok(
    content.includes("export type CelValidationMixedUnion ="),
    "Should find CelValidationMixedUnion type definition",
  );

  // Extract the CelValidationMixedUnion type definition
  const mixedRegex =
    /export type CelValidationMixedUnion =([\s\S]+?)(?=export const CelValidationMixedUnionSchema)/;
  const mixedMatch = content.match(mixedRegex);
  assert.ok(mixedMatch, "Should find CelValidationMixedUnion type definition");

  const mixedTypeBody = mixedMatch[1];

  // Should be a union type with name omitted from all branches, and email/phone omitted in branches
  assert.ok(
    !mixedTypeBody.includes("name:"),
    "Should NOT include name (omitted from all branches)",
  );
  assert.ok(
    mixedTypeBody.includes("email"),
    "Should reference email in one branch",
  );
  assert.ok(
    mixedTypeBody.includes("phone"),
    "Should reference phone in one branch",
  );
});
