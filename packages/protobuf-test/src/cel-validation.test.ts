// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Tests for buf.validate CEL-based read-only field omission in generated code.
 *
 * IMPORTANT: The real validation happens at TypeScript compile time, not runtime.
 * These tests verify that the generated TypeScript DEFINITIONS are correct by:
 *
 * 1. Checking the generated .d.ts type structure matches expectations
 * 2. Ensuring TypeScript compilation itself validates the field omissions
 *    (TypeScript will error if trying to assign omitted fields)
 * 3. Verifying that code generation produces valid, usable types
 *
 * NOTE: Runtime tests cannot verify TypeScript type omissions - the real test
 * is that this code compiles successfully with TypeScript's type checker.
 */

import { test } from "node:test";
import * as assert from "node:assert";
import { readFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Path to generated TypeScript definitions
const generatedFilePath = join(
  __dirname,
  "gen/ts,cel_validation/extra/cel-validation_types_pb.ts",
);

// Helper to assert field presence/absence in a type definition body
function assertField(
  typeBody: string,
  fieldName: string,
  shouldExist: boolean,
  message?: string,
) {
  // Regex to match field definition: fieldName: or fieldName?:
  // We use \b to ensure we match the whole word
  const fieldRegex = new RegExp(`\\b${fieldName}\\??\\s*:`);
  const exists = fieldRegex.test(typeBody);

  if (shouldExist) {
    assert.ok(exists, message || `Should include ${fieldName} field`);
  } else {
    assert.ok(
      !exists,
      message || `Should NOT include ${fieldName} field (omitted)`,
    );
  }
}

// Helper to extract type definition body
function getTypeBody(content: string, typeName: string): string {
  const regex = new RegExp(
    `export type ${typeName} = Message<[^>]+> & \\{([\\s\\S]+?)\\}`,
  );
  const match = content.match(regex);
  assert.ok(match, `Should find ${typeName} type definition`);
  return match[1];
}

// Helper to extract union type definition body
function getUnionTypeBody(content: string, typeName: string): string {
  const regex = new RegExp(
    `export type ${typeName} =([\\s\\S]+?)(?=export (const|type))`,
  );
  const match = content.match(regex);
  assert.ok(match, `Should find ${typeName} type definition`);
  return match[1];
}

test("Generated code exists and is valid TypeScript", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  assert.ok(content.length > 0, "Generated file should not be empty");
  assert.ok(
    content.includes("@generated by protoc-gen-es"),
    "Should be generated by protoc-gen-es",
  );
});

test("CelValidationSimple type omits 'name' field from Shape", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationSimple");

  assertField(typeBody, "description", true);
  assertField(typeBody, "age", true);
  assertField(typeBody, "name", false, "name should be omitted due to CEL");
});

test("CelValidationMultiple type omits 'id' and 'code' fields", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationMultiple");

  assertField(typeBody, "title", true);
  assertField(typeBody, "active", true);
  assertField(typeBody, "id", false, "id should be omitted");
  assertField(typeBody, "code", false, "code should be omitted");
});

test("CelValidationNotHas type omits 'optionalField' due to !has()", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationNotHas");

  assertField(typeBody, "otherField", true);
  assertField(
    typeBody,
    "optionalField",
    false,
    "optionalField should be omitted",
  );
});

test("CelValidationNested type uses Omit for nested field constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationNested");

  assertField(typeBody, "parentField", true);
  assertField(typeBody, "nested", true);

  // Should use Omit for nested type
  assert.ok(
    typeBody.includes("Omit<"),
    "Should use Omit<> for nested field type",
  );
  assert.ok(
    typeBody.includes("childName"),
    "Should reference childName in Omit<>",
  );
  assert.ok(
    typeBody.includes("childCount"),
    "Should reference childCount in Omit<>",
  );
});

test("CelValidationSnakeCase converts field names to camelCase", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationSnakeCase");

  assertField(typeBody, "firstName", true);
  assertField(typeBody, "lastName", true);
  assertField(typeBody, "userName", false, "userName should be omitted");
});

test("CelValidationNoCel includes ALL fields when no CEL constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationNoCel");

  assertField(typeBody, "name", true);
  assertField(typeBody, "description", true);
});

test("CelValidationOr includes ALL fields (OR doesn't create read-only)", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  // OR constraint generates a union type
  assert.ok(
    content.includes("export type CelValidationOr ="),
    "Should find CelValidationOr type definition",
  );

  const unionBody = getUnionTypeBody(content, "CelValidationOr");

  // Now we expect fields to be present as optional never in the branches where they are omitted
  // Branch 1: field1 is empty -> field1?: never
  // Branch 2: field2 is empty -> field2?: never

  // Since we can't easily parse the exact structure with regex, we check for the presence of the never definitions
  assert.ok(
    unionBody.includes("field1?: never"),
    "Should include field1?: never",
  );
  assert.ok(
    unionBody.includes("field2?: never"),
    "Should include field2?: never",
  );

  // field3 should be present normally
  assert.ok(unionBody.includes("field3"), "Should include field3");
});

test("CelValidationCombined omits fields from AND constraint", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationCombined");

  assertField(typeBody, "field3", true);
  assertField(typeBody, "field1", false, "field1 should be omitted");
  assertField(typeBody, "field2", false, "field2 should be omitted");
});

test("CelValidationWithRequired keeps required field, omits readonly field", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationWithRequired");

  assertField(typeBody, "requiredField", true);
  assertField(
    typeBody,
    "readonlyField",
    false,
    "readonlyField should be omitted",
  );
});

test("Valid types also have correct field omissions", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const typeBody = getTypeBody(content, "CelValidationSimpleValid");

  assertField(typeBody, "description", true);
  assertField(typeBody, "name", false, "Valid type should also omit name");
});

test("CelValidationUnion generates union type with OR constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationUnion")) {
    console.log("CelValidationUnion not found, skipping");
    return;
  }

  const unionBody = getUnionTypeBody(content, "CelValidationUnion");

  // Check for strict union with never
  assert.ok(
    unionBody.includes("email?: never"),
    "Should include email?: never in one branch",
  );
  assert.ok(
    unionBody.includes("phone?: never"),
    "Should include phone?: never in one branch",
  );
  assert.ok(unionBody.includes("name"), "Should include name field");
});

test("CelValidationNestedUnion generates union type with nested OR constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationNestedUnion")) {
    return;
  }

  const unionBody = getUnionTypeBody(content, "CelValidationNestedUnion");

  assert.ok(
    unionBody.includes("Omit<"),
    "Should use Omit<> for nested union branches",
  );
  assert.ok(
    unionBody.includes("street"),
    "Should reference street in union branches",
  );
  assert.ok(
    unionBody.includes("city"),
    "Should reference city in union branches",
  );
});

test("CelValidationMixedUnion generates complex union type with AND+OR", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationMixedUnion")) {
    return;
  }

  const unionBody = getUnionTypeBody(content, "CelValidationMixedUnion");

  // Name is omitted globally, so it shouldn't be present as a property or never
  const namePropRegex = /\bname\??\s*:/;
  assert.ok(
    !namePropRegex.test(unionBody),
    "Should NOT include name property definition",
  );

  // Email and phone should be never in respective branches
  assert.ok(
    unionBody.includes("email?: never"),
    "Should include email?: never",
  );
  assert.ok(
    unionBody.includes("phone?: never"),
    "Should include phone?: never",
  );
});

test("CelValidationMultipleNested handles multiple nested constraints", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationMultipleNested")) {
    return;
  }

  const typeBody = getTypeBody(content, "CelValidationMultipleNested");

  assertField(typeBody, "parentName", true);
  assertField(typeBody, "child1", true);
  assertField(typeBody, "child2", true);

  // Should use Omit for both child1 and child2
  // We expect something like:
  // child1?: Omit<NestedChild, "childName">;
  // child2?: Omit<NestedChild, "childValue">;

  assert.ok(
    typeBody.includes("childName"),
    "Should reference childName in Omit",
  );
  assert.ok(
    typeBody.includes("childValue"),
    "Should reference childValue in Omit",
  );
});

test("CelValidationWithRepeated handles repeated fields correctly", () => {
  const content = readFileSync(generatedFilePath, "utf-8");

  if (!content.includes("CelValidationWithRepeated")) {
    return;
  }

  const typeBody = getTypeBody(content, "CelValidationWithRepeated");

  assertField(typeBody, "singleField", false, "singleField should be omitted");
  assertField(typeBody, "listField", true);
  assertField(typeBody, "nestedList", true);
});

test("CelValidationOrValid uses strict union with never", () => {
  const content = readFileSync(generatedFilePath, "utf-8");
  const unionBody = getUnionTypeBody(content, "CelValidationOrValid");

  assert.ok(
    unionBody.includes("field1?: never"),
    "Should include field1?: never in Valid type union",
  );
  assert.ok(
    unionBody.includes("field2?: never"),
    "Should include field2?: never in Valid type union",
  );
});
