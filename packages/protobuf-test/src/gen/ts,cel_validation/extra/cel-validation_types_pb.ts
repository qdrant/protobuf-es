// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,import_extension=js,valid_types=protovalidate_required+legacy_required"
// @generated from file extra/cel-validation_types.proto (package spec, edition 2023)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import { file_extra_minimal_validate } from "./minimal-validate_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file extra/cel-validation_types.proto.
 */
export const file_extra_cel_validation_types: GenFile = /*@__PURE__*/
  fileDesc("CiBleHRyYS9jZWwtdmFsaWRhdGlvbl90eXBlcy5wcm90bxIEc3BlYyKAAQoTQ2VsVmFsaWRhdGlvblNpbXBsZRIMCgRuYW1lGAEgASgJEhMKC2Rlc2NyaXB0aW9uGAIgASgJEgsKA2FnZRgDIAEoBTo5ukg2GjQKDXJlYWRvbmx5X25hbWUSEm5hbWUgbXVzdCBiZSBlbXB0eRoPdGhpcy5uYW1lID09ICcnIrkBChVDZWxWYWxpZGF0aW9uTXVsdGlwbGUSCgoCaWQYASABKAkSDAoEY29kZRgCIAEoBRINCgV0aXRsZRgDIAEoCRIOCgZhY3RpdmUYBCABKAg6Z7pIZBouCgtyZWFkb25seV9pZBIQaWQgbXVzdCBiZSBlbXB0eRoNdGhpcy5pZCA9PSAnJxoyCg1yZWFkb25seV9jb2RlEhFjb2RlIG11c3QgYmUgemVybxoOdGhpcy5jb2RlID09IDAinQEKE0NlbFZhbGlkYXRpb25Ob3RIYXMSFgoOb3B0aW9uYWxfZmllbGQYASABKAkSEwoLb3RoZXJfZmllbGQYAiABKAk6WbpIVhpUChdyZWFkb25seV9vcHRpb25hbF9maWVsZBIeb3B0aW9uYWxfZmllbGQgbXVzdCBub3QgYmUgc2V0GhkhaGFzKHRoaXMub3B0aW9uYWxfZmllbGQpIksKC05lc3RlZENoaWxkEhIKCmNoaWxkX25hbWUYASABKAkSEwoLY2hpbGRfdmFsdWUYAiABKAkSEwoLY2hpbGRfY291bnQYAyABKAUikAIKE0NlbFZhbGlkYXRpb25OZXN0ZWQSIQoGbmVzdGVkGAEgASgLMhEuc3BlYy5OZXN0ZWRDaGlsZBIUCgxwYXJlbnRfZmllbGQYAiABKAk6vwG6SLsBGlsKGnJlYWRvbmx5X25lc3RlZF9jaGlsZF9uYW1lEh9uZXN0ZWQuY2hpbGRfbmFtZSBtdXN0IGJlIGVtcHR5Ghx0aGlzLm5lc3RlZC5jaGlsZF9uYW1lID09ICcnGlwKG3JlYWRvbmx5X25lc3RlZF9jaGlsZF9jb3VudBIfbmVzdGVkLmNoaWxkX2NvdW50IG11c3QgYmUgemVybxocdGhpcy5uZXN0ZWQuY2hpbGRfY291bnQgPT0gMCKqAQoVQ2VsVmFsaWRhdGlvbkNvbWJpbmVkEg4KBmZpZWxkMRgBIAEoCRIOCgZmaWVsZDIYAiABKAkSDgoGZmllbGQzGAMgASgJOmG6SF4aXAoRcmVhZG9ubHlfY29tYmluZWQSH2ZpZWxkMSBhbmQgZmllbGQyIG11c3QgYmUgZW1wdHkaJnRoaXMuZmllbGQxID09ICcnICYmIHRoaXMuZmllbGQyID09ICcnIpgBChZDZWxWYWxpZGF0aW9uU25ha2VDYXNlEhEKCXVzZXJfbmFtZRgBIAEoCRISCgpmaXJzdF9uYW1lGAIgASgJEhEKCWxhc3RfbmFtZRgDIAEoCTpEukhBGj8KDnJlYWRvbmx5X3NuYWtlEhd1c2VyX25hbWUgbXVzdCBiZSBlbXB0eRoUdGhpcy51c2VyX25hbWUgPT0gJyciNwoSQ2VsVmFsaWRhdGlvbk5vQ2VsEgwKBG5hbWUYASABKAkSEwoLZGVzY3JpcHRpb24YAiABKAkisAIKG0NlbFZhbGlkYXRpb25NdWx0aXBsZU5lc3RlZBIhCgZjaGlsZDEYASABKAsyES5zcGVjLk5lc3RlZENoaWxkEiEKBmNoaWxkMhgCIAEoCzIRLnNwZWMuTmVzdGVkQ2hpbGQSEwoLcGFyZW50X25hbWUYAyABKAk6tQG6SLEBGlUKFHJlYWRvbmx5X2NoaWxkMV9uYW1lEh9jaGlsZDEuY2hpbGRfbmFtZSBtdXN0IGJlIGVtcHR5Ghx0aGlzLmNoaWxkMS5jaGlsZF9uYW1lID09ICcnGlgKFXJlYWRvbmx5X2NoaWxkMl92YWx1ZRIgY2hpbGQyLmNoaWxkX3ZhbHVlIG11c3QgYmUgZW1wdHkaHXRoaXMuY2hpbGQyLmNoaWxkX3ZhbHVlID09ICcnIsIBChlDZWxWYWxpZGF0aW9uV2l0aFJlcXVpcmVkEhYKDnJlYWRvbmx5X2ZpZWxkGAEgASgJEh4KDnJlcXVpcmVkX2ZpZWxkGAIgASgJQga6SAPIAQESFAoMbm9ybWFsX2ZpZWxkGAMgASgJOle6SFQaUgoXcmVhZG9ubHlfcmVhZG9ubHlfZmllbGQSHHJlYWRvbmx5X2ZpZWxkIG11c3QgYmUgZW1wdHkaGXRoaXMucmVhZG9ubHlfZmllbGQgPT0gJycinQEKD0NlbFZhbGlkYXRpb25PchIOCgZmaWVsZDEYASABKAkSDgoGZmllbGQyGAIgASgJEg4KBmZpZWxkMxgDIAEoCTpaukhXGlUKC3JlYWRvbmx5X29yEh5maWVsZDEgb3IgZmllbGQyIG11c3QgYmUgZW1wdHkaJnRoaXMuZmllbGQxID09ICcnIHx8IHRoaXMuZmllbGQyID09ICcnIroBChlDZWxWYWxpZGF0aW9uV2l0aFJlcGVhdGVkEhQKDHNpbmdsZV9maWVsZBgBIAEoCRISCgpsaXN0X2ZpZWxkGAIgAygJEiYKC25lc3RlZF9saXN0GAMgAygLMhEuc3BlYy5OZXN0ZWRDaGlsZDpLukhIGkYKD3JlYWRvbmx5X3NpbmdsZRIac2luZ2xlX2ZpZWxkIG11c3QgYmUgZW1wdHkaF3RoaXMuc2luZ2xlX2ZpZWxkID09ICcnIqgBChJDZWxWYWxpZGF0aW9uVW5pb24SDQoFZW1haWwYASABKAkSDQoFcGhvbmUYAiABKAkSDAoEbmFtZRgDIAEoCTpmukhjGmEKFHVuaW9uX2VtYWlsX29yX3Bob25lEiNlaXRoZXIgZW1haWwgb3IgcGhvbmUgbXVzdCBiZSBlbXB0eRokdGhpcy5lbWFpbCA9PSAnJyB8fCB0aGlzLnBob25lID09ICcnIr8BChhDZWxWYWxpZGF0aW9uTmVzdGVkVW5pb24SHgoHYWRkcmVzcxgBIAEoCzINLnNwZWMuQWRkcmVzcxIMCgRuYW1lGAIgASgJOnW6SHIacAoTdW5pb25fbmVzdGVkX2ZpZWxkcxIjZWl0aGVyIHN0cmVldCBvciBjaXR5IG11c3QgYmUgZW1wdHkaNHRoaXMuYWRkcmVzcy5zdHJlZXQgPT0gJycgfHwgdGhpcy5hZGRyZXNzLmNpdHkgPT0gJyci1QEKF0NlbFZhbGlkYXRpb25NaXhlZFVuaW9uEgwKBG5hbWUYASABKAkSDQoFZW1haWwYAiABKAkSDQoFcGhvbmUYAyABKAk6jQG6SIkBGoYBCgxtaXhlZF9hbmRfb3ISO25hbWUgbXVzdCBiZSBlbXB0eSwgYW5kIGVpdGhlciBlbWFpbCBvciBwaG9uZSBtdXN0IGJlIGVtcHR5Gjl0aGlzLm5hbWUgPT0gJycgJiYgKHRoaXMuZW1haWwgPT0gJycgfHwgdGhpcy5waG9uZSA9PSAnJykiOAoHQWRkcmVzcxIOCgZzdHJlZXQYASABKAkSDAoEY2l0eRgCIAEoCRIPCgdjb3VudHJ5GAMgASgJYghlZGl0aW9uc3DoBw", [file_extra_minimal_validate]);

/**
 * Test message for buf_validate with simple read-only field constraints
 *
 * @generated from message spec.CelValidationSimple
 */
export type CelValidationSimple = Message<"spec.CelValidationSimple"> & {
  /**
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * @generated from field: int32 age = 3;
   */
  age: number;
}

/**
 * Test message for buf_validate with simple read-only field constraints
 *
 * @generated from message spec.CelValidationSimple
 */
export type CelValidationSimpleValid = Message<"spec.CelValidationSimple"> & {
  /**
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * @generated from field: int32 age = 3;
   */
  age: number;
}

/**
 * Describes the message spec.CelValidationSimple.
 * Use `create(CelValidationSimpleSchema)` to create a new message.
 */
export const CelValidationSimpleSchema: GenMessage<CelValidationSimple, {validType: CelValidationSimpleValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 0);

/**
 * Test message for buf_validate with multiple read-only fields
 *
 * @generated from message spec.CelValidationMultiple
 */
export type CelValidationMultiple = Message<"spec.CelValidationMultiple"> & {
  /**
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * @generated from field: bool active = 4;
   */
  active: boolean;
}

/**
 * Test message for buf_validate with multiple read-only fields
 *
 * @generated from message spec.CelValidationMultiple
 */
export type CelValidationMultipleValid = Message<"spec.CelValidationMultiple"> & {
  /**
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * @generated from field: bool active = 4;
   */
  active: boolean;
}

/**
 * Describes the message spec.CelValidationMultiple.
 * Use `create(CelValidationMultipleSchema)` to create a new message.
 */
export const CelValidationMultipleSchema: GenMessage<CelValidationMultiple, {validType: CelValidationMultipleValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 1);

/**
 * Test message for buf_validate with !has() pattern
 *
 * @generated from message spec.CelValidationNotHas
 */
export type CelValidationNotHas = Message<"spec.CelValidationNotHas"> & {
  /**
   * @generated from field: string other_field = 2;
   */
  otherField: string;
}

/**
 * Test message for buf_validate with !has() pattern
 *
 * @generated from message spec.CelValidationNotHas
 */
export type CelValidationNotHasValid = Message<"spec.CelValidationNotHas"> & {
  /**
   * @generated from field: string other_field = 2;
   */
  otherField: string;
}

/**
 * Describes the message spec.CelValidationNotHas.
 * Use `create(CelValidationNotHasSchema)` to create a new message.
 */
export const CelValidationNotHasSchema: GenMessage<CelValidationNotHas, {validType: CelValidationNotHasValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 2);

/**
 * Nested message for testing nested constraints
 *
 * @generated from message spec.NestedChild
 */
export type NestedChild = Message<"spec.NestedChild"> & {
  /**
   * @generated from field: string child_name = 1;
   */
  childName: string;

  /**
   * @generated from field: string child_value = 2;
   */
  childValue: string;

  /**
   * @generated from field: int32 child_count = 3;
   */
  childCount: number;
}

/**
 * Nested message for testing nested constraints
 *
 * @generated from message spec.NestedChild
 */
export type NestedChildValid = Message<"spec.NestedChild"> & {
  /**
   * @generated from field: string child_name = 1;
   */
  childName: string;

  /**
   * @generated from field: string child_value = 2;
   */
  childValue: string;

  /**
   * @generated from field: int32 child_count = 3;
   */
  childCount: number;
}

/**
 * Describes the message spec.NestedChild.
 * Use `create(NestedChildSchema)` to create a new message.
 */
export const NestedChildSchema: GenMessage<NestedChild, {validType: NestedChildValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 3);

/**
 * Test message for buf_validate with nested field constraints
 *
 * @generated from message spec.CelValidationNested
 */
export type CelValidationNested = Message<"spec.CelValidationNested"> & {
  /**
   * @generated from field: spec.NestedChild nested = 1;
   */
  nested?: Omit<NestedChild, 'childName' | 'childCount'>;

  /**
   * @generated from field: string parent_field = 2;
   */
  parentField: string;
}

/**
 * Test message for buf_validate with nested field constraints
 *
 * @generated from message spec.CelValidationNested
 */
export type CelValidationNestedValid = Message<"spec.CelValidationNested"> & {
  /**
   * @generated from field: spec.NestedChild nested = 1;
   */
  nested?: Omit<NestedChildValid, 'childName' | 'childCount'>;

  /**
   * @generated from field: string parent_field = 2;
   */
  parentField: string;
}

/**
 * Describes the message spec.CelValidationNested.
 * Use `create(CelValidationNestedSchema)` to create a new message.
 */
export const CelValidationNestedSchema: GenMessage<CelValidationNested, {validType: CelValidationNestedValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 4);

/**
 * Test message combining multiple CEL patterns with logical operators
 *
 * @generated from message spec.CelValidationCombined
 */
export type CelValidationCombined = Message<"spec.CelValidationCombined"> & {
  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}

/**
 * Test message combining multiple CEL patterns with logical operators
 *
 * @generated from message spec.CelValidationCombined
 */
export type CelValidationCombinedValid = Message<"spec.CelValidationCombined"> & {
  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}

/**
 * Describes the message spec.CelValidationCombined.
 * Use `create(CelValidationCombinedSchema)` to create a new message.
 */
export const CelValidationCombinedSchema: GenMessage<CelValidationCombined, {validType: CelValidationCombinedValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 5);

/**
 * Test message with snake_case fields that should be converted to camelCase
 *
 * @generated from message spec.CelValidationSnakeCase
 */
export type CelValidationSnakeCase = Message<"spec.CelValidationSnakeCase"> & {
  /**
   * @generated from field: string first_name = 2;
   */
  firstName: string;

  /**
   * @generated from field: string last_name = 3;
   */
  lastName: string;
}

/**
 * Test message with snake_case fields that should be converted to camelCase
 *
 * @generated from message spec.CelValidationSnakeCase
 */
export type CelValidationSnakeCaseValid = Message<"spec.CelValidationSnakeCase"> & {
  /**
   * @generated from field: string first_name = 2;
   */
  firstName: string;

  /**
   * @generated from field: string last_name = 3;
   */
  lastName: string;
}

/**
 * Describes the message spec.CelValidationSnakeCase.
 * Use `create(CelValidationSnakeCaseSchema)` to create a new message.
 */
export const CelValidationSnakeCaseSchema: GenMessage<CelValidationSnakeCase, {validType: CelValidationSnakeCaseValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 6);

/**
 * Test message without CEL constraints (should not apply Omit)
 *
 * @generated from message spec.CelValidationNoCel
 */
export type CelValidationNoCel = Message<"spec.CelValidationNoCel"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Test message without CEL constraints (should not apply Omit)
 *
 * @generated from message spec.CelValidationNoCel
 */
export type CelValidationNoCelValid = Message<"spec.CelValidationNoCel"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Describes the message spec.CelValidationNoCel.
 * Use `create(CelValidationNoCelSchema)` to create a new message.
 */
export const CelValidationNoCelSchema: GenMessage<CelValidationNoCel, {validType: CelValidationNoCelValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 7);

/**
 * Test message with multiple nested constraints on different fields
 *
 * @generated from message spec.CelValidationMultipleNested
 */
export type CelValidationMultipleNested = Message<"spec.CelValidationMultipleNested"> & {
  /**
   * @generated from field: spec.NestedChild child1 = 1;
   */
  child1?: Omit<NestedChild, 'childName'>;

  /**
   * @generated from field: spec.NestedChild child2 = 2;
   */
  child2?: Omit<NestedChild, 'childValue'>;

  /**
   * @generated from field: string parent_name = 3;
   */
  parentName: string;
}

/**
 * Test message with multiple nested constraints on different fields
 *
 * @generated from message spec.CelValidationMultipleNested
 */
export type CelValidationMultipleNestedValid = Message<"spec.CelValidationMultipleNested"> & {
  /**
   * @generated from field: spec.NestedChild child1 = 1;
   */
  child1?: Omit<NestedChildValid, 'childName'>;

  /**
   * @generated from field: spec.NestedChild child2 = 2;
   */
  child2?: Omit<NestedChildValid, 'childValue'>;

  /**
   * @generated from field: string parent_name = 3;
   */
  parentName: string;
}

/**
 * Describes the message spec.CelValidationMultipleNested.
 * Use `create(CelValidationMultipleNestedSchema)` to create a new message.
 */
export const CelValidationMultipleNestedSchema: GenMessage<CelValidationMultipleNested, {validType: CelValidationMultipleNestedValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 8);

/**
 * Test message with required field and buf_validate
 *
 * @generated from message spec.CelValidationWithRequired
 */
export type CelValidationWithRequired = Message<"spec.CelValidationWithRequired"> & {
  /**
   * @generated from field: string required_field = 2;
   */
  requiredField: string;

  /**
   * @generated from field: string normal_field = 3;
   */
  normalField: string;
}

/**
 * Test message with required field and buf_validate
 *
 * @generated from message spec.CelValidationWithRequired
 */
export type CelValidationWithRequiredValid = Message<"spec.CelValidationWithRequired"> & {
  /**
   * @generated from field: string required_field = 2;
   */
  requiredField: string;

  /**
   * @generated from field: string normal_field = 3;
   */
  normalField: string;
}

/**
 * Describes the message spec.CelValidationWithRequired.
 * Use `create(CelValidationWithRequiredSchema)` to create a new message.
 */
export const CelValidationWithRequiredSchema: GenMessage<CelValidationWithRequired, {validType: CelValidationWithRequiredValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 9);

/**
 * Test message for OR logical operator
 *
 * @generated from message spec.CelValidationOr
 */
export type CelValidationOr = 
Message<"spec.CelValidationOr"> & {
  /**
   * @generated from field: string field2 = 2;
   */
  field2: string;

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}
 | 
Message<"spec.CelValidationOr"> & {
  /**
   * @generated from field: string field1 = 1;
   */
  field1: string;

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}

/**
 * Test message for OR logical operator
 *
 * @generated from message spec.CelValidationOr
 */
export type CelValidationOrValid = 
Message<"spec.CelValidationOr"> & {
  /**
   * @generated from field: string field2 = 2;
   */
  field2: string;

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}
 | 
Message<"spec.CelValidationOr"> & {
  /**
   * @generated from field: string field1 = 1;
   */
  field1: string;

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}

/**
 * Describes the message spec.CelValidationOr.
 * Use `create(CelValidationOrSchema)` to create a new message.
 */
export const CelValidationOrSchema: GenMessage<CelValidationOr, {validType: CelValidationOrValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 10);

/**
 * Test message with repeated fields
 *
 * @generated from message spec.CelValidationWithRepeated
 */
export type CelValidationWithRepeated = Message<"spec.CelValidationWithRepeated"> & {
  /**
   * @generated from field: repeated string list_field = 2;
   */
  listField: string[];

  /**
   * @generated from field: repeated spec.NestedChild nested_list = 3;
   */
  nestedList: NestedChild[];
}

/**
 * Test message with repeated fields
 *
 * @generated from message spec.CelValidationWithRepeated
 */
export type CelValidationWithRepeatedValid = Message<"spec.CelValidationWithRepeated"> & {
  /**
   * @generated from field: repeated string list_field = 2;
   */
  listField: string[];

  /**
   * @generated from field: repeated spec.NestedChild nested_list = 3;
   */
  nestedList: NestedChildValid[];
}

/**
 * Describes the message spec.CelValidationWithRepeated.
 * Use `create(CelValidationWithRepeatedSchema)` to create a new message.
 */
export const CelValidationWithRepeatedSchema: GenMessage<CelValidationWithRepeated, {validType: CelValidationWithRepeatedValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 11);

/**
 * Test message with OR constraints that should generate union types
 *
 * @generated from message spec.CelValidationUnion
 */
export type CelValidationUnion = 
Message<"spec.CelValidationUnion"> & {
  /**
   * @generated from field: string phone = 2;
   */
  phone: string;

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;
}
 | 
Message<"spec.CelValidationUnion"> & {
  /**
   * @generated from field: string email = 1;
   */
  email: string;

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;
}

/**
 * Test message with OR constraints that should generate union types
 *
 * @generated from message spec.CelValidationUnion
 */
export type CelValidationUnionValid = 
Message<"spec.CelValidationUnion"> & {
  /**
   * @generated from field: string phone = 2;
   */
  phone: string;

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;
}
 | 
Message<"spec.CelValidationUnion"> & {
  /**
   * @generated from field: string email = 1;
   */
  email: string;

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;
}

/**
 * Describes the message spec.CelValidationUnion.
 * Use `create(CelValidationUnionSchema)` to create a new message.
 */
export const CelValidationUnionSchema: GenMessage<CelValidationUnion, {validType: CelValidationUnionValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 12);

/**
 * Test message with nested OR constraints
 *
 * @generated from message spec.CelValidationNestedUnion
 */
export type CelValidationNestedUnion = 
Message<"spec.CelValidationNestedUnion"> & {
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<Address, 'street'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;
}
 | 
Message<"spec.CelValidationNestedUnion"> & {
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<Address, 'city'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;
}

/**
 * Test message with nested OR constraints
 *
 * @generated from message spec.CelValidationNestedUnion
 */
export type CelValidationNestedUnionValid = 
Message<"spec.CelValidationNestedUnion"> & {
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<AddressValid, 'street'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;
}
 | 
Message<"spec.CelValidationNestedUnion"> & {
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<AddressValid, 'city'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;
}

/**
 * Describes the message spec.CelValidationNestedUnion.
 * Use `create(CelValidationNestedUnionSchema)` to create a new message.
 */
export const CelValidationNestedUnionSchema: GenMessage<CelValidationNestedUnion, {validType: CelValidationNestedUnionValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 13);

/**
 * Test message with mixed AND/OR constraints
 *
 * @generated from message spec.CelValidationMixedUnion
 */
export type CelValidationMixedUnion = 
Message<"spec.CelValidationMixedUnion"> & {
  /**
   * Omitted in the other union branch
   *
   * @generated from field: string phone = 3;
   */
  phone: string;
}
 | 
Message<"spec.CelValidationMixedUnion"> & {
  /**
   * Omitted in one union branch
   *
   * @generated from field: string email = 2;
   */
  email: string;

}

/**
 * Test message with mixed AND/OR constraints
 *
 * @generated from message spec.CelValidationMixedUnion
 */
export type CelValidationMixedUnionValid = 
Message<"spec.CelValidationMixedUnion"> & {
  /**
   * Omitted in the other union branch
   *
   * @generated from field: string phone = 3;
   */
  phone: string;
}
 | 
Message<"spec.CelValidationMixedUnion"> & {
  /**
   * Omitted in one union branch
   *
   * @generated from field: string email = 2;
   */
  email: string;

}

/**
 * Describes the message spec.CelValidationMixedUnion.
 * Use `create(CelValidationMixedUnionSchema)` to create a new message.
 */
export const CelValidationMixedUnionSchema: GenMessage<CelValidationMixedUnion, {validType: CelValidationMixedUnionValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 14);

/**
 * Address message for nested tests
 *
 * @generated from message spec.Address
 */
export type Address = Message<"spec.Address"> & {
  /**
   * @generated from field: string street = 1;
   */
  street: string;

  /**
   * @generated from field: string city = 2;
   */
  city: string;

  /**
   * @generated from field: string country = 3;
   */
  country: string;
}

/**
 * Address message for nested tests
 *
 * @generated from message spec.Address
 */
export type AddressValid = Message<"spec.Address"> & {
  /**
   * @generated from field: string street = 1;
   */
  street: string;

  /**
   * @generated from field: string city = 2;
   */
  city: string;

  /**
   * @generated from field: string country = 3;
   */
  country: string;
}

/**
 * Describes the message spec.Address.
 * Use `create(AddressSchema)` to create a new message.
 */
export const AddressSchema: GenMessage<Address, {validType: AddressValid}> = /*@__PURE__*/
  messageDesc(file_extra_cel_validation_types, 15);

