// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.10.1 with parameter "target=js+dts,import_extension=js"
// @generated from file extra/cel-validation_types.proto (package spec, edition 2023)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file extra/cel-validation_types.proto.
 */
export declare const file_extra_cel_validation_types: GenFile;

/**
 * Test message for buf_validate with simple read-only field constraints
 *
 * @generated from message spec.CelValidationSimple
 */
export declare type CelValidationSimple = Message<"spec.CelValidationSimple"> & {
  /**
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * @generated from field: int32 age = 3;
   */
  age: number;
}

/**
 * Describes the message spec.CelValidationSimple.
 * Use `create(CelValidationSimpleSchema)` to create a new message.
 */
export declare const CelValidationSimpleSchema: GenMessage<CelValidationSimple>;

/**
 * Test message for buf_validate with multiple read-only fields
 *
 * @generated from message spec.CelValidationMultiple
 */
export declare type CelValidationMultiple = Message<"spec.CelValidationMultiple"> & {
  /**
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * @generated from field: bool active = 4;
   */
  active: boolean;
}

/**
 * Describes the message spec.CelValidationMultiple.
 * Use `create(CelValidationMultipleSchema)` to create a new message.
 */
export declare const CelValidationMultipleSchema: GenMessage<CelValidationMultiple>;

/**
 * Test message for buf_validate with !has() pattern
 *
 * @generated from message spec.CelValidationNotHas
 */
export declare type CelValidationNotHas = Message<"spec.CelValidationNotHas"> & {
  /**
   * @generated from field: string other_field = 2;
   */
  otherField: string;
}

/**
 * Describes the message spec.CelValidationNotHas.
 * Use `create(CelValidationNotHasSchema)` to create a new message.
 */
export declare const CelValidationNotHasSchema: GenMessage<CelValidationNotHas>;

/**
 * Nested message for testing nested constraints
 *
 * @generated from message spec.NestedChild
 */
export declare type NestedChild = Message<"spec.NestedChild"> & {
  /**
   * @generated from field: string child_name = 1;
   */
  childName: string;

  /**
   * @generated from field: string child_value = 2;
   */
  childValue: string;

  /**
   * @generated from field: int32 child_count = 3;
   */
  childCount: number;
}

/**
 * Describes the message spec.NestedChild.
 * Use `create(NestedChildSchema)` to create a new message.
 */
export declare const NestedChildSchema: GenMessage<NestedChild>;

/**
 * Test message for buf_validate with nested field constraints
 *
 * @generated from message spec.CelValidationNested
 */
export declare type CelValidationNested = Message<"spec.CelValidationNested"> & {
  /**
   * @generated from field: spec.NestedChild nested = 1;
   */
  nested?: Omit<NestedChild, 'childName' | 'childCount'>;

  /**
   * @generated from field: string parent_field = 2;
   */
  parentField: string;
}

/**
 * Describes the message spec.CelValidationNested.
 * Use `create(CelValidationNestedSchema)` to create a new message.
 */
export declare const CelValidationNestedSchema: GenMessage<CelValidationNested>;

/**
 * Test message combining multiple CEL patterns with logical operators
 *
 * @generated from message spec.CelValidationCombined
 */
export declare type CelValidationCombined = Message<"spec.CelValidationCombined"> & {
  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}

/**
 * Describes the message spec.CelValidationCombined.
 * Use `create(CelValidationCombinedSchema)` to create a new message.
 */
export declare const CelValidationCombinedSchema: GenMessage<CelValidationCombined>;

/**
 * Test message with snake_case fields that should be converted to camelCase
 *
 * @generated from message spec.CelValidationSnakeCase
 */
export declare type CelValidationSnakeCase = Message<"spec.CelValidationSnakeCase"> & {
  /**
   * @generated from field: string first_name = 2;
   */
  firstName: string;

  /**
   * @generated from field: string last_name = 3;
   */
  lastName: string;
}

/**
 * Describes the message spec.CelValidationSnakeCase.
 * Use `create(CelValidationSnakeCaseSchema)` to create a new message.
 */
export declare const CelValidationSnakeCaseSchema: GenMessage<CelValidationSnakeCase>;

/**
 * Test message without CEL constraints (should not apply Omit)
 *
 * @generated from message spec.CelValidationNoCel
 */
export declare type CelValidationNoCel = Message<"spec.CelValidationNoCel"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Describes the message spec.CelValidationNoCel.
 * Use `create(CelValidationNoCelSchema)` to create a new message.
 */
export declare const CelValidationNoCelSchema: GenMessage<CelValidationNoCel>;

/**
 * Test message with multiple nested constraints on different fields
 *
 * @generated from message spec.CelValidationMultipleNested
 */
export declare type CelValidationMultipleNested = Message<"spec.CelValidationMultipleNested"> & {
  /**
   * @generated from field: spec.NestedChild child1 = 1;
   */
  child1?: Omit<NestedChild, 'childName'>;

  /**
   * @generated from field: spec.NestedChild child2 = 2;
   */
  child2?: Omit<NestedChild, 'childValue'>;

  /**
   * @generated from field: string parent_name = 3;
   */
  parentName: string;
}

/**
 * Describes the message spec.CelValidationMultipleNested.
 * Use `create(CelValidationMultipleNestedSchema)` to create a new message.
 */
export declare const CelValidationMultipleNestedSchema: GenMessage<CelValidationMultipleNested>;

/**
 * Test message with required field and buf_validate
 *
 * @generated from message spec.CelValidationWithRequired
 */
export declare type CelValidationWithRequired = Message<"spec.CelValidationWithRequired"> & {
  /**
   * @generated from field: string required_field = 2;
   */
  requiredField: string;

  /**
   * @generated from field: string normal_field = 3;
   */
  normalField: string;
}

/**
 * Describes the message spec.CelValidationWithRequired.
 * Use `create(CelValidationWithRequiredSchema)` to create a new message.
 */
export declare const CelValidationWithRequiredSchema: GenMessage<CelValidationWithRequired>;

/**
 * Test message for OR logical operator
 *
 * @generated from message spec.CelValidationOr
 */
export declare type CelValidationOr = 
Message<"spec.CelValidationOr"> & {
  /**
   * @generated from field: string field2 = 2;
   */
  field2: string;

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}
 | 
Message<"spec.CelValidationOr"> & {
  /**
   * @generated from field: string field1 = 1;
   */
  field1: string;

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}

/**
 * Describes the message spec.CelValidationOr.
 * Use `create(CelValidationOrSchema)` to create a new message.
 */
export declare const CelValidationOrSchema: GenMessage<CelValidationOr>;

/**
 * Test message with repeated fields
 *
 * @generated from message spec.CelValidationWithRepeated
 */
export declare type CelValidationWithRepeated = Message<"spec.CelValidationWithRepeated"> & {
  /**
   * @generated from field: repeated string list_field = 2;
   */
  listField: string[];

  /**
   * @generated from field: repeated spec.NestedChild nested_list = 3;
   */
  nestedList: NestedChild[];
}

/**
 * Describes the message spec.CelValidationWithRepeated.
 * Use `create(CelValidationWithRepeatedSchema)` to create a new message.
 */
export declare const CelValidationWithRepeatedSchema: GenMessage<CelValidationWithRepeated>;

/**
 * Test message with OR constraints that should generate union types
 *
 * @generated from message spec.CelValidationUnion
 */
export declare type CelValidationUnion = 
Message<"spec.CelValidationUnion"> & {
  /**
   * @generated from field: string phone = 2;
   */
  phone: string;

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;
}
 | 
Message<"spec.CelValidationUnion"> & {
  /**
   * @generated from field: string email = 1;
   */
  email: string;

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;
}

/**
 * Describes the message spec.CelValidationUnion.
 * Use `create(CelValidationUnionSchema)` to create a new message.
 */
export declare const CelValidationUnionSchema: GenMessage<CelValidationUnion>;

/**
 * Test message with nested OR constraints
 *
 * @generated from message spec.CelValidationNestedUnion
 */
export declare type CelValidationNestedUnion = 
Message<"spec.CelValidationNestedUnion"> & {
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<Address, 'street'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;
}
 | 
Message<"spec.CelValidationNestedUnion"> & {
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<Address, 'city'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;
}

/**
 * Describes the message spec.CelValidationNestedUnion.
 * Use `create(CelValidationNestedUnionSchema)` to create a new message.
 */
export declare const CelValidationNestedUnionSchema: GenMessage<CelValidationNestedUnion>;

/**
 * Test message with mixed AND/OR constraints
 *
 * @generated from message spec.CelValidationMixedUnion
 */
export declare type CelValidationMixedUnion = 
Message<"spec.CelValidationMixedUnion"> & {
  /**
   * Omitted in the other union branch
   *
   * @generated from field: string phone = 3;
   */
  phone: string;
}
 | 
Message<"spec.CelValidationMixedUnion"> & {
  /**
   * Omitted in one union branch
   *
   * @generated from field: string email = 2;
   */
  email: string;

}

/**
 * Describes the message spec.CelValidationMixedUnion.
 * Use `create(CelValidationMixedUnionSchema)` to create a new message.
 */
export declare const CelValidationMixedUnionSchema: GenMessage<CelValidationMixedUnion>;

/**
 * Address message for nested tests
 *
 * @generated from message spec.Address
 */
export declare type Address = Message<"spec.Address"> & {
  /**
   * @generated from field: string street = 1;
   */
  street: string;

  /**
   * @generated from field: string city = 2;
   */
  city: string;

  /**
   * @generated from field: string country = 3;
   */
  country: string;
}

/**
 * Describes the message spec.Address.
 * Use `create(AddressSchema)` to create a new message.
 */
export declare const AddressSchema: GenMessage<Address>;

