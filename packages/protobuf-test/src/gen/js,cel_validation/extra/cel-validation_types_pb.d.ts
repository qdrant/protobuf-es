// Copyright 2021-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.10.1 with parameter "target=js+dts,import_extension=js,valid_types=protovalidate_required+legacy_required"
// @generated from file extra/cel-validation_types.proto (package spec, edition 2023)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file extra/cel-validation_types.proto.
 */
export declare const file_extra_cel_validation_types: GenFile;

/**
 * Test message for buf_validate with simple read-only field constraints
 *
 * @generated from message spec.CelValidationSimple
 */
export declare type CelValidationSimple = Message<"spec.CelValidationSimple"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: "";

  /**
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * @generated from field: int32 age = 3;
   */
  age: number;
}

/**
 * Test message for buf_validate with simple read-only field constraints
 *
 * @generated from message spec.CelValidationSimple
 */
export declare type CelValidationSimpleValid = Message<"spec.CelValidationSimple"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: "";

  /**
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * @generated from field: int32 age = 3;
   */
  age: number;
}

/**
 * Describes the message spec.CelValidationSimple.
 * Use `create(CelValidationSimpleSchema)` to create a new message.
 */
export declare const CelValidationSimpleSchema: GenMessage<CelValidationSimple, {validType: CelValidationSimpleValid}>;

/**
 * Test message for buf_validate with multiple read-only fields
 *
 * @generated from message spec.CelValidationMultiple
 */
export declare type CelValidationMultiple = Message<"spec.CelValidationMultiple"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: "";

  /**
   * @generated from field: int32 code = 2;
   */
  code: 0;

  /**
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * @generated from field: bool active = 4;
   */
  active: boolean;
}

/**
 * Test message for buf_validate with multiple read-only fields
 *
 * @generated from message spec.CelValidationMultiple
 */
export declare type CelValidationMultipleValid = Message<"spec.CelValidationMultiple"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: "";

  /**
   * @generated from field: int32 code = 2;
   */
  code: 0;

  /**
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * @generated from field: bool active = 4;
   */
  active: boolean;
}

/**
 * Describes the message spec.CelValidationMultiple.
 * Use `create(CelValidationMultipleSchema)` to create a new message.
 */
export declare const CelValidationMultipleSchema: GenMessage<CelValidationMultiple, {validType: CelValidationMultipleValid}>;

/**
 * Test message for buf_validate with !has() pattern
 *
 * @generated from message spec.CelValidationNotHas
 */
export declare type CelValidationNotHas = Message<"spec.CelValidationNotHas"> & {
  /**
   * @generated from field: string other_field = 2;
   */
  otherField: string;
}

/**
 * Test message for buf_validate with !has() pattern
 *
 * @generated from message spec.CelValidationNotHas
 */
export declare type CelValidationNotHasValid = Message<"spec.CelValidationNotHas"> & {
  /**
   * @generated from field: string other_field = 2;
   */
  otherField: string;
}

/**
 * Describes the message spec.CelValidationNotHas.
 * Use `create(CelValidationNotHasSchema)` to create a new message.
 */
export declare const CelValidationNotHasSchema: GenMessage<CelValidationNotHas, {validType: CelValidationNotHasValid}>;

/**
 * Nested message for testing nested constraints
 *
 * @generated from message spec.NestedChild
 */
export declare type NestedChild = Message<"spec.NestedChild"> & {
  /**
   * @generated from field: string child_name = 1;
   */
  childName: string;

  /**
   * @generated from field: string child_value = 2;
   */
  childValue: string;

  /**
   * @generated from field: int32 child_count = 3;
   */
  childCount: number;
}

/**
 * Nested message for testing nested constraints
 *
 * @generated from message spec.NestedChild
 */
export declare type NestedChildValid = Message<"spec.NestedChild"> & {
  /**
   * @generated from field: string child_name = 1;
   */
  childName: string;

  /**
   * @generated from field: string child_value = 2;
   */
  childValue: string;

  /**
   * @generated from field: int32 child_count = 3;
   */
  childCount: number;
}

/**
 * Describes the message spec.NestedChild.
 * Use `create(NestedChildSchema)` to create a new message.
 */
export declare const NestedChildSchema: GenMessage<NestedChild, {validType: NestedChildValid}>;

/**
 * Test message for buf_validate with nested field constraints
 *
 * @generated from message spec.CelValidationNested
 */
export declare type CelValidationNested = Message<"spec.CelValidationNested"> & {
  /**
   * @generated from field: spec.NestedChild nested = 1;
   */
  nested?: Omit<NestedChild, 'childName' | 'childCount'>;

  /**
   * @generated from field: string parent_field = 2;
   */
  parentField: string;
}

/**
 * Test message for buf_validate with nested field constraints
 *
 * @generated from message spec.CelValidationNested
 */
export declare type CelValidationNestedValid = Message<"spec.CelValidationNested"> & {
  /**
   * @generated from field: spec.NestedChild nested = 1;
   */
  nested?: Omit<NestedChildValid, 'childName' | 'childCount'>;

  /**
   * @generated from field: string parent_field = 2;
   */
  parentField: string;
}

/**
 * Describes the message spec.CelValidationNested.
 * Use `create(CelValidationNestedSchema)` to create a new message.
 */
export declare const CelValidationNestedSchema: GenMessage<CelValidationNested, {validType: CelValidationNestedValid}>;

/**
 * Test message combining multiple CEL patterns with logical operators
 *
 * @generated from message spec.CelValidationCombined
 */
export declare type CelValidationCombined = Message<"spec.CelValidationCombined"> & {
  /**
   * @generated from field: string field1 = 1;
   */
  field1: "";

  /**
   * @generated from field: string field2 = 2;
   */
  field2: "";

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}

/**
 * Test message combining multiple CEL patterns with logical operators
 *
 * @generated from message spec.CelValidationCombined
 */
export declare type CelValidationCombinedValid = Message<"spec.CelValidationCombined"> & {
  /**
   * @generated from field: string field1 = 1;
   */
  field1: "";

  /**
   * @generated from field: string field2 = 2;
   */
  field2: "";

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;
}

/**
 * Describes the message spec.CelValidationCombined.
 * Use `create(CelValidationCombinedSchema)` to create a new message.
 */
export declare const CelValidationCombinedSchema: GenMessage<CelValidationCombined, {validType: CelValidationCombinedValid}>;

/**
 * Test message with snake_case fields that should be converted to camelCase
 *
 * @generated from message spec.CelValidationSnakeCase
 */
export declare type CelValidationSnakeCase = Message<"spec.CelValidationSnakeCase"> & {
  /**
   * @generated from field: string user_name = 1;
   */
  userName: "";

  /**
   * @generated from field: string first_name = 2;
   */
  firstName: string;

  /**
   * @generated from field: string last_name = 3;
   */
  lastName: string;
}

/**
 * Test message with snake_case fields that should be converted to camelCase
 *
 * @generated from message spec.CelValidationSnakeCase
 */
export declare type CelValidationSnakeCaseValid = Message<"spec.CelValidationSnakeCase"> & {
  /**
   * @generated from field: string user_name = 1;
   */
  userName: "";

  /**
   * @generated from field: string first_name = 2;
   */
  firstName: string;

  /**
   * @generated from field: string last_name = 3;
   */
  lastName: string;
}

/**
 * Describes the message spec.CelValidationSnakeCase.
 * Use `create(CelValidationSnakeCaseSchema)` to create a new message.
 */
export declare const CelValidationSnakeCaseSchema: GenMessage<CelValidationSnakeCase, {validType: CelValidationSnakeCaseValid}>;

/**
 * Test message without CEL constraints (should not apply Omit)
 *
 * @generated from message spec.CelValidationNoCel
 */
export declare type CelValidationNoCel = Message<"spec.CelValidationNoCel"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Test message without CEL constraints (should not apply Omit)
 *
 * @generated from message spec.CelValidationNoCel
 */
export declare type CelValidationNoCelValid = Message<"spec.CelValidationNoCel"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Describes the message spec.CelValidationNoCel.
 * Use `create(CelValidationNoCelSchema)` to create a new message.
 */
export declare const CelValidationNoCelSchema: GenMessage<CelValidationNoCel, {validType: CelValidationNoCelValid}>;

/**
 * Test message with multiple nested constraints on different fields
 *
 * @generated from message spec.CelValidationMultipleNested
 */
export declare type CelValidationMultipleNested = Message<"spec.CelValidationMultipleNested"> & {
  /**
   * @generated from field: spec.NestedChild child1 = 1;
   */
  child1?: Omit<NestedChild, 'childName'>;

  /**
   * @generated from field: spec.NestedChild child2 = 2;
   */
  child2?: Omit<NestedChild, 'childValue'>;

  /**
   * @generated from field: string parent_name = 3;
   */
  parentName: string;
}

/**
 * Test message with multiple nested constraints on different fields
 *
 * @generated from message spec.CelValidationMultipleNested
 */
export declare type CelValidationMultipleNestedValid = Message<"spec.CelValidationMultipleNested"> & {
  /**
   * @generated from field: spec.NestedChild child1 = 1;
   */
  child1?: Omit<NestedChildValid, 'childName'>;

  /**
   * @generated from field: spec.NestedChild child2 = 2;
   */
  child2?: Omit<NestedChildValid, 'childValue'>;

  /**
   * @generated from field: string parent_name = 3;
   */
  parentName: string;
}

/**
 * Describes the message spec.CelValidationMultipleNested.
 * Use `create(CelValidationMultipleNestedSchema)` to create a new message.
 */
export declare const CelValidationMultipleNestedSchema: GenMessage<CelValidationMultipleNested, {validType: CelValidationMultipleNestedValid}>;

/**
 * Test message with required field and buf_validate
 *
 * @generated from message spec.CelValidationWithRequired
 */
export declare type CelValidationWithRequired = Message<"spec.CelValidationWithRequired"> & {
  /**
   * @generated from field: string readonly_field = 1;
   */
  readonlyField: "";

  /**
   * @generated from field: string required_field = 2;
   */
  requiredField: string;

  /**
   * @generated from field: string normal_field = 3;
   */
  normalField: string;
}

/**
 * Test message with required field and buf_validate
 *
 * @generated from message spec.CelValidationWithRequired
 */
export declare type CelValidationWithRequiredValid = Message<"spec.CelValidationWithRequired"> & {
  /**
   * @generated from field: string readonly_field = 1;
   */
  readonlyField: "";

  /**
   * @generated from field: string required_field = 2;
   */
  requiredField: string;

  /**
   * @generated from field: string normal_field = 3;
   */
  normalField: string;
}

/**
 * Describes the message spec.CelValidationWithRequired.
 * Use `create(CelValidationWithRequiredSchema)` to create a new message.
 */
export declare const CelValidationWithRequiredSchema: GenMessage<CelValidationWithRequired, {validType: CelValidationWithRequiredValid}>;

/**
 * Test message for OR logical operator
 *
 * @generated from message spec.CelValidationOr
 */
export declare type CelValidationOr = Message<"spec.CelValidationOr"> & (
{
  /**
   * @generated from field: string field1 = 1;
   */
  field1: "";

  /**
   * @generated from field: string field2 = 2;
   */
  field2: string;

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;

}
 | 
{
  /**
   * @generated from field: string field1 = 1;
   */
  field1: string;

  /**
   * @generated from field: string field2 = 2;
   */
  field2: "";

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;

}
);

/**
 * Test message for OR logical operator
 *
 * @generated from message spec.CelValidationOr
 */
export declare type CelValidationOrValid = Message<"spec.CelValidationOr"> & (
{
  /**
   * @generated from field: string field1 = 1;
   */
  field1: "";

  /**
   * @generated from field: string field2 = 2;
   */
  field2: string;

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;

}
 | 
{
  /**
   * @generated from field: string field1 = 1;
   */
  field1: string;

  /**
   * @generated from field: string field2 = 2;
   */
  field2: "";

  /**
   * @generated from field: string field3 = 3;
   */
  field3: string;

}
);

/**
 * Describes the message spec.CelValidationOr.
 * Use `create(CelValidationOrSchema)` to create a new message.
 */
export declare const CelValidationOrSchema: GenMessage<CelValidationOr, {validType: CelValidationOrValid}>;

/**
 * Test message with repeated fields
 *
 * @generated from message spec.CelValidationWithRepeated
 */
export declare type CelValidationWithRepeated = Message<"spec.CelValidationWithRepeated"> & {
  /**
   * @generated from field: string single_field = 1;
   */
  singleField: "";

  /**
   * @generated from field: repeated string list_field = 2;
   */
  listField: string[];

  /**
   * @generated from field: repeated spec.NestedChild nested_list = 3;
   */
  nestedList: NestedChild[];
}

/**
 * Test message with repeated fields
 *
 * @generated from message spec.CelValidationWithRepeated
 */
export declare type CelValidationWithRepeatedValid = Message<"spec.CelValidationWithRepeated"> & {
  /**
   * @generated from field: string single_field = 1;
   */
  singleField: "";

  /**
   * @generated from field: repeated string list_field = 2;
   */
  listField: string[];

  /**
   * @generated from field: repeated spec.NestedChild nested_list = 3;
   */
  nestedList: NestedChildValid[];
}

/**
 * Describes the message spec.CelValidationWithRepeated.
 * Use `create(CelValidationWithRepeatedSchema)` to create a new message.
 */
export declare const CelValidationWithRepeatedSchema: GenMessage<CelValidationWithRepeated, {validType: CelValidationWithRepeatedValid}>;

/**
 * Test message with OR constraints that should generate union types
 *
 * @generated from message spec.CelValidationUnion
 */
export declare type CelValidationUnion = Message<"spec.CelValidationUnion"> & (
{
  /**
   * @generated from field: string email = 1;
   */
  email: "";

  /**
   * @generated from field: string phone = 2;
   */
  phone: string;

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;

}
 | 
{
  /**
   * @generated from field: string email = 1;
   */
  email: string;

  /**
   * @generated from field: string phone = 2;
   */
  phone: "";

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;

}
);

/**
 * Test message with OR constraints that should generate union types
 *
 * @generated from message spec.CelValidationUnion
 */
export declare type CelValidationUnionValid = Message<"spec.CelValidationUnion"> & (
{
  /**
   * @generated from field: string email = 1;
   */
  email: "";

  /**
   * @generated from field: string phone = 2;
   */
  phone: string;

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;

}
 | 
{
  /**
   * @generated from field: string email = 1;
   */
  email: string;

  /**
   * @generated from field: string phone = 2;
   */
  phone: "";

  /**
   * This should always be present
   *
   * @generated from field: string name = 3;
   */
  name: string;

}
);

/**
 * Describes the message spec.CelValidationUnion.
 * Use `create(CelValidationUnionSchema)` to create a new message.
 */
export declare const CelValidationUnionSchema: GenMessage<CelValidationUnion, {validType: CelValidationUnionValid}>;

/**
 * Test message with nested OR constraints
 *
 * @generated from message spec.CelValidationNestedUnion
 */
export declare type CelValidationNestedUnion = Message<"spec.CelValidationNestedUnion"> & (
{
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<Address, 'street'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

}
 | 
{
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<Address, 'city'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

}
);

/**
 * Test message with nested OR constraints
 *
 * @generated from message spec.CelValidationNestedUnion
 */
export declare type CelValidationNestedUnionValid = Message<"spec.CelValidationNestedUnion"> & (
{
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<AddressValid, 'street'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

}
 | 
{
  /**
   * @generated from field: spec.Address address = 1;
   */
  address?: Omit<AddressValid, 'city'>;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

}
);

/**
 * Describes the message spec.CelValidationNestedUnion.
 * Use `create(CelValidationNestedUnionSchema)` to create a new message.
 */
export declare const CelValidationNestedUnionSchema: GenMessage<CelValidationNestedUnion, {validType: CelValidationNestedUnionValid}>;

/**
 * Test message with mixed AND/OR constraints
 *
 * @generated from message spec.CelValidationMixedUnion
 */
export declare type CelValidationMixedUnion = Message<"spec.CelValidationMixedUnion"> & (
{
  /**
   * Always omitted
   *
   * @generated from field: string name = 1;
   */
  name: "";

  /**
   * Omitted in one union branch
   *
   * @generated from field: string email = 2;
   */
  email: "";

  /**
   * Omitted in the other union branch
   *
   * @generated from field: string phone = 3;
   */
  phone: string;

}
 | 
{
  /**
   * Always omitted
   *
   * @generated from field: string name = 1;
   */
  name: "";

  /**
   * Omitted in one union branch
   *
   * @generated from field: string email = 2;
   */
  email: string;

  /**
   * Omitted in the other union branch
   *
   * @generated from field: string phone = 3;
   */
  phone: "";

}
);

/**
 * Test message with mixed AND/OR constraints
 *
 * @generated from message spec.CelValidationMixedUnion
 */
export declare type CelValidationMixedUnionValid = Message<"spec.CelValidationMixedUnion"> & (
{
  /**
   * Always omitted
   *
   * @generated from field: string name = 1;
   */
  name: "";

  /**
   * Omitted in one union branch
   *
   * @generated from field: string email = 2;
   */
  email: "";

  /**
   * Omitted in the other union branch
   *
   * @generated from field: string phone = 3;
   */
  phone: string;

}
 | 
{
  /**
   * Always omitted
   *
   * @generated from field: string name = 1;
   */
  name: "";

  /**
   * Omitted in one union branch
   *
   * @generated from field: string email = 2;
   */
  email: string;

  /**
   * Omitted in the other union branch
   *
   * @generated from field: string phone = 3;
   */
  phone: "";

}
);

/**
 * Describes the message spec.CelValidationMixedUnion.
 * Use `create(CelValidationMixedUnionSchema)` to create a new message.
 */
export declare const CelValidationMixedUnionSchema: GenMessage<CelValidationMixedUnion, {validType: CelValidationMixedUnionValid}>;

/**
 * Address message for nested tests
 *
 * @generated from message spec.Address
 */
export declare type Address = Message<"spec.Address"> & {
  /**
   * @generated from field: string street = 1;
   */
  street: string;

  /**
   * @generated from field: string city = 2;
   */
  city: string;

  /**
   * @generated from field: string country = 3;
   */
  country: string;
}

/**
 * Address message for nested tests
 *
 * @generated from message spec.Address
 */
export declare type AddressValid = Message<"spec.Address"> & {
  /**
   * @generated from field: string street = 1;
   */
  street: string;

  /**
   * @generated from field: string city = 2;
   */
  city: string;

  /**
   * @generated from field: string country = 3;
   */
  country: string;
}

/**
 * Describes the message spec.Address.
 * Use `create(AddressSchema)` to create a new message.
 */
export declare const AddressSchema: GenMessage<Address, {validType: AddressValid}>;

/**
 * Test message with literal string constraint
 *
 * @generated from message spec.CelValidationLiteralString
 */
export declare type CelValidationLiteralString = Message<"spec.CelValidationLiteralString"> & {
  /**
   * Should be typed as "active", not string
   *
   * @generated from field: string status = 1;
   */
  status: "active";

  /**
   * @generated from field: string name = 2;
   */
  name: string;
}

/**
 * Test message with literal string constraint
 *
 * @generated from message spec.CelValidationLiteralString
 */
export declare type CelValidationLiteralStringValid = Message<"spec.CelValidationLiteralString"> & {
  /**
   * Should be typed as "active", not string
   *
   * @generated from field: string status = 1;
   */
  status: "active";

  /**
   * @generated from field: string name = 2;
   */
  name: string;
}

/**
 * Describes the message spec.CelValidationLiteralString.
 * Use `create(CelValidationLiteralStringSchema)` to create a new message.
 */
export declare const CelValidationLiteralStringSchema: GenMessage<CelValidationLiteralString, {validType: CelValidationLiteralStringValid}>;

/**
 * Test message with literal number constraint
 *
 * @generated from message spec.CelValidationLiteralNumber
 */
export declare type CelValidationLiteralNumber = Message<"spec.CelValidationLiteralNumber"> & {
  /**
   * Should be typed as 1, not int32
   *
   * @generated from field: int32 version = 1;
   */
  version: 1;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Test message with literal number constraint
 *
 * @generated from message spec.CelValidationLiteralNumber
 */
export declare type CelValidationLiteralNumberValid = Message<"spec.CelValidationLiteralNumber"> & {
  /**
   * Should be typed as 1, not int32
   *
   * @generated from field: int32 version = 1;
   */
  version: 1;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Describes the message spec.CelValidationLiteralNumber.
 * Use `create(CelValidationLiteralNumberSchema)` to create a new message.
 */
export declare const CelValidationLiteralNumberSchema: GenMessage<CelValidationLiteralNumber, {validType: CelValidationLiteralNumberValid}>;

/**
 * Test message with literal boolean constraint
 *
 * @generated from message spec.CelValidationLiteralBool
 */
export declare type CelValidationLiteralBool = Message<"spec.CelValidationLiteralBool"> & {
  /**
   * Should be typed as true, not bool
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: true;

  /**
   * @generated from field: string note = 2;
   */
  note: string;
}

/**
 * Test message with literal boolean constraint
 *
 * @generated from message spec.CelValidationLiteralBool
 */
export declare type CelValidationLiteralBoolValid = Message<"spec.CelValidationLiteralBool"> & {
  /**
   * Should be typed as true, not bool
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: true;

  /**
   * @generated from field: string note = 2;
   */
  note: string;
}

/**
 * Describes the message spec.CelValidationLiteralBool.
 * Use `create(CelValidationLiteralBoolSchema)` to create a new message.
 */
export declare const CelValidationLiteralBoolSchema: GenMessage<CelValidationLiteralBool, {validType: CelValidationLiteralBoolValid}>;

/**
 * Test message with multiple literal constraints
 *
 * @generated from message spec.CelValidationLiteralsMultiple
 */
export declare type CelValidationLiteralsMultiple = Message<"spec.CelValidationLiteralsMultiple"> & {
  /**
   * Should be "user"
   *
   * @generated from field: string type = 1;
   */
  type: "user";

  /**
   * Should be 5
   *
   * @generated from field: int32 level = 2;
   */
  level: 5;

  /**
   * @generated from field: string info = 3;
   */
  info: string;
}

/**
 * Test message with multiple literal constraints
 *
 * @generated from message spec.CelValidationLiteralsMultiple
 */
export declare type CelValidationLiteralsMultipleValid = Message<"spec.CelValidationLiteralsMultiple"> & {
  /**
   * Should be "user"
   *
   * @generated from field: string type = 1;
   */
  type: "user";

  /**
   * Should be 5
   *
   * @generated from field: int32 level = 2;
   */
  level: 5;

  /**
   * @generated from field: string info = 3;
   */
  info: string;
}

/**
 * Describes the message spec.CelValidationLiteralsMultiple.
 * Use `create(CelValidationLiteralsMultipleSchema)` to create a new message.
 */
export declare const CelValidationLiteralsMultipleSchema: GenMessage<CelValidationLiteralsMultiple, {validType: CelValidationLiteralsMultipleValid}>;

/**
 * Test message with literal in OR constraint
 *
 * @generated from message spec.CelValidationLiteralOr
 */
export declare type CelValidationLiteralOr = Message<"spec.CelValidationLiteralOr"> & (
{
  /**
   * Should be "admin" in one branch
   *
   * @generated from field: string role = 1;
   */
  role: "admin";

  /**
   * Should be "pending" in the other branch
   *
   * @generated from field: string status = 2;
   */
  status: string;

  /**
   * @generated from field: string name = 3;
   */
  name: string;

}
 | 
{
  /**
   * Should be "admin" in one branch
   *
   * @generated from field: string role = 1;
   */
  role: string;

  /**
   * Should be "pending" in the other branch
   *
   * @generated from field: string status = 2;
   */
  status: "pending";

  /**
   * @generated from field: string name = 3;
   */
  name: string;

}
);

/**
 * Test message with literal in OR constraint
 *
 * @generated from message spec.CelValidationLiteralOr
 */
export declare type CelValidationLiteralOrValid = Message<"spec.CelValidationLiteralOr"> & (
{
  /**
   * Should be "admin" in one branch
   *
   * @generated from field: string role = 1;
   */
  role: "admin";

  /**
   * Should be "pending" in the other branch
   *
   * @generated from field: string status = 2;
   */
  status: string;

  /**
   * @generated from field: string name = 3;
   */
  name: string;

}
 | 
{
  /**
   * Should be "admin" in one branch
   *
   * @generated from field: string role = 1;
   */
  role: string;

  /**
   * Should be "pending" in the other branch
   *
   * @generated from field: string status = 2;
   */
  status: "pending";

  /**
   * @generated from field: string name = 3;
   */
  name: string;

}
);

/**
 * Describes the message spec.CelValidationLiteralOr.
 * Use `create(CelValidationLiteralOrSchema)` to create a new message.
 */
export declare const CelValidationLiteralOrSchema: GenMessage<CelValidationLiteralOr, {validType: CelValidationLiteralOrValid}>;

/**
 * Test message with literal boolean false constraint
 *
 * @generated from message spec.CelValidationLiteralBoolFalse
 */
export declare type CelValidationLiteralBoolFalse = Message<"spec.CelValidationLiteralBoolFalse"> & {
  /**
   * Should be typed as false, not bool
   *
   * @generated from field: bool disabled = 1;
   */
  disabled: false;

  /**
   * @generated from field: string reason = 2;
   */
  reason: string;
}

/**
 * Test message with literal boolean false constraint
 *
 * @generated from message spec.CelValidationLiteralBoolFalse
 */
export declare type CelValidationLiteralBoolFalseValid = Message<"spec.CelValidationLiteralBoolFalse"> & {
  /**
   * Should be typed as false, not bool
   *
   * @generated from field: bool disabled = 1;
   */
  disabled: false;

  /**
   * @generated from field: string reason = 2;
   */
  reason: string;
}

/**
 * Describes the message spec.CelValidationLiteralBoolFalse.
 * Use `create(CelValidationLiteralBoolFalseSchema)` to create a new message.
 */
export declare const CelValidationLiteralBoolFalseSchema: GenMessage<CelValidationLiteralBoolFalse, {validType: CelValidationLiteralBoolFalseValid}>;

/**
 * Test message with literal enum constraint
 * Demonstrates that enum values in TypeScript are numbers,
 * so this.status == 2 should generate: status: 2
 *
 * @generated from message spec.CelValidationLiteralEnum
 */
export declare type CelValidationLiteralEnum = Message<"spec.CelValidationLiteralEnum"> & {
  /**
   * Should be typed as literal 2 (STATUS_ACTIVE)
   *
   * @generated from field: spec.Status status = 1;
   */
  status: 2;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Test message with literal enum constraint
 * Demonstrates that enum values in TypeScript are numbers,
 * so this.status == 2 should generate: status: 2
 *
 * @generated from message spec.CelValidationLiteralEnum
 */
export declare type CelValidationLiteralEnumValid = Message<"spec.CelValidationLiteralEnum"> & {
  /**
   * Should be typed as literal 2 (STATUS_ACTIVE)
   *
   * @generated from field: spec.Status status = 1;
   */
  status: 2;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
}

/**
 * Describes the message spec.CelValidationLiteralEnum.
 * Use `create(CelValidationLiteralEnumSchema)` to create a new message.
 */
export declare const CelValidationLiteralEnumSchema: GenMessage<CelValidationLiteralEnum, {validType: CelValidationLiteralEnumValid}>;

/**
 * Enum for testing literal enum constraints
 *
 * @generated from enum spec.Status
 */
export enum Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: STATUS_ACTIVE = 2;
   */
  ACTIVE = 2,

  /**
   * @generated from enum value: STATUS_INACTIVE = 3;
   */
  INACTIVE = 3,
}

/**
 * Describes the enum spec.Status.
 */
export declare const StatusSchema: GenEnum<Status>;

